
compounds
    ++ => == && || ->
end compounds

keys
    Bool 'case class def 'else fn 'function 'if in Integer let 'of return switch Text 'then 'type var
end keys


define program
    [expression] % | [repeat functionDefinition] | [repeat typeDefinition]
end define

tokens
    boolean "false" | "true"
    undefined "undefined"
end tokens

define expression
    [sub]
    | [multiplition]
    | [division] 
    | [string_concat]
    | [equal]
    | [and]
    | [or]
    | [atom]
    | [addition]
    | [var_declaration]
    
end define

define or
    [atom]
    | [atom] '|| [expression]
end define

define and
    [atom]
    | [atom] && [expression]
end define

define equal
    [atom]
    | [atom] == [expression]
end define

define addition
    [atom]
    | [atom] + [expression]
end define

define sub
    [atom]
    | [atom] - [expression]
end define

define multiplition
    [atom]
    | [atom] * [expression]
end define

define division
    [atom]
    | [atom] / [expression]
end define

% kann man bestimmt gut für die Präsentation nehmen
define string_concat
    [stringlit]
    | [stringlit] ++ [string_concat] % diese Zeile muss vor [stringlit] ++ [stringlit] stehen damit auch bei nur 2 Strings die Umwandlung klappt - verstehe ich aber nicht genau
    | [stringlit] + [stringlit]
    | [stringlit] + [string_concat]
end define

define var_declaration
    let [id] '= [expression] in [expression]
    | var [id] '= [expression] [NL] [expression] % das nach dem in ist einfach ein Ausdruck der in eine neue Zeile muss
end define


define atom
   [number] % number kann anscheinend nur positive Zahlen
   | [stringlit]
   | [boolean]
   | [id]
   | [lambda]
   | [function_call]
end define

define lambda
   fn [id] => [expression]
   | fn [id] : [type]  => [expression]
   | '( [id] ') => '{ [NL] [return_expression]
end define

define return_expression
    [expression] '}
    | return [expression] [NL] '}
end define

define type
    Bool
    | Integer
    | Text
    | [type]
    | [type] -> [type]
end define

% ist in beiden Sprachen gleich
define function_call
    [id] '( [expression] ') [function_call]
    | '( [expression] ') [function_call]
    | [empty]
end define