
compounds
    ++ => == && || ->
end compounds

keys
    Bool 'case class def 'else fn 'function 'if in Integer let 'of return switch Text 'then 'type var
end keys


define program
     [expression] % | [repeat functionDefinition] | [repeat typeDefinition]
end define

tokens
    boolean "false" | "true"
    undefined "undefined"
end tokens

define expression
    [atom] 
    | [expression] + [expression] 
    | [expression] - [expression] 
    | [expression] * [expression] 
    | [expression] / [expression] 
    | [string_concat]
    | [expression] && [expression]
    | [expression] || [expression] 
    | [expression] == [expression] 
    | [var_declaration]
end define

% kann man bestimmt gut für die Präsentation nehmen
define string_concat
    [stringlit]
    | [stringlit] ++ [string_concat] % diese Zeile muss vor [stringlit] ++ [stringlit] stehen damit auch bei nur 2 Strings die Umwandlung klappt - verstehe ich aber nicht genau
    | [stringlit] ++ [stringlit] 
    | [stringlit] + [stringlit]
    | [stringlit] + [string_concat]
end define

define var_declaration
    let [id] '= [expression] in [expression]
    | var [id] '= [expression] [NL] [expression] % das nach dem in ist einfach ein Ausdruck der in eine neue Zeile muss
end define


define atom
   [number] % number kann anscheinend nur positive Zahlen
   | [stringlit]
   | [boolean]
   | [id]
   | [lambda]
   | [function_call]
end define

define lambda
   fn [id] => [expression]
   | fn [id] : [type]  => [expression]
   | '( [id] ') => '{ [NL] [expression] [NL] '}
end define

define type
    Bool
    | Integer
    | Text
    | [type]
    | [type] -> [type]
end define

% ist in beiden Sprachen gleich
define function_call
    [id] '( [expression] ')
end define